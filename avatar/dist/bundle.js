// Generated by CoffeeScript 2.3.1
var avatar, binary, compose, crop, err, express, image, os, profile, render, reply, request, resize, resizeCoef, sharp;

os = require("os");

sharp = require("sharp");

// Safely perform mutation operations on an image buffer.

// @param {buffer} buf - Image buffer.
// @returns {sharp} - Cloned image buffer with the sharp module.
image = function(buf) {
  return sharp(buf).clone();
};

// Crop out a section of an image buffer.

// @param {buffer} buf - Image buffer.
// @param {integer} x - Left-hand upper corner x-coordinate.
// @param {integer} y - Left-hand upper corner y-coordinate.
// @param {integer} w - Width in pixels of the crop section.
// @param {integer} h - Height in pixels of the crop section.
// @returns {promise<buffer>} - Image buffer of the cropped section.
crop = function(buf, x, y, w, h) {
  return image(buf).extract({
    left: x,
    top: y,
    width: w,
    height: h
  }).toBuffer();
};

// Place one image buffer on top of another.

// @param {buffer} buf0 - Image buffer at the bottom.
// @param {buffer} buf1 - Image buffer placed on top.
// @param {integer} x - Left-hand upper corner x-coordinate to place image.
// @param {integer} y - Left-hand upper corner y-coordinate to place image.
// @returns {promise<buffer>} - Image buffer with the composed image.
compose = function(buf0, buf1, x = 0, y = 0) {
  return image(buf0).overlayWith(buf1, {
    left: x,
    top: y
  }).toBuffer();
};

// Resize an image to a new width and height.

// Uses the nearestNeighbor algorithm to keep
// pixel density without blurring.

// @param {buffer} buf - Image buffer to resize.
// @param {integer} size - Width and height in pixels of the new image.
// @returns {promise<buffer>} - Image buffer of resized image.
resize = function(buf, size) {
  size = Math.max(0, size);
  return image(buf).resize(size * resizeCoef, size * resizeCoef, {
    kernel: sharp.kernel.nearest,
    interpolator: sharp.interpolator.nearest,
    centerSampling: true
  }).png().toBuffer();
};

resizeCoef = 2;

// Reduce IO operations because of impodency.
sharp.cache({
  memory: os.freemem() * 1000 * 0.75
});

// Allocate dedicated threads to process images.
sharp.concurrency(8);

// Enable special image vectoring to improve IO performance.
sharp.simd(true);

// Render the avatars of a user given their UUID or username.

// @param {string} id - UUID or username.
// @returns {promise<buffer>} - Image buffer of face and hat.
render = function(id, size) {
  return profile(id).then(function(data) {
    var e, skin, url;
    // TEMP: Backwards compatible between base64 and url.
    // Can be removed once api v0.2 is deployed.
    skin = data.textures.skin;
    try {
      url = new URL(skin);
      return binary(data.textures.skin);
    } catch (error) {
      e = error;
      return Buffer.from(skin, "base64");
    }
  }).then(function(buf) {
    return avatar(buf, size);
  });
};

// Render the face and hat of a user.

// @param {buffer} buf - Image buffer of the raw skin texture.
// @param {integer} size - Size in pixels to transform the image.
// @returns {promise<buffer>} - Image buffer of face and hat.
avatar = function(buf, size) {
  return Promise.all([crop(buf, 8, 8, 8, 8), crop(buf, 40, 8, 8, 8)]).then(function([face, hat]) {
    return compose(face, hat);
  }).then(function(both) {
    return resize(both, size);
  });
};

reply = function(req, res) {
  var id, size;
  [id, size] = req.url.split("/").slice(1, 3);
  if (id == null) {
    id = "Steve";
  }
  size = Math.min(1024, Math.max(8, parseInt(size) || 8));
  return render(id, size).then(function(buf) {
    return [200, buf];
  }).catch(function(err) {
    return render("Steve", size).then(function(buf) {
      return [err.statusCode, buf];
    });
  }).then(function([code, buf]) {
    res.set("Content-Type", "image/png");
    return res.status(code).send(buf);
  }).catch(function(err) {
    res.status(500).end();
    return console.error(err);
  });
};

try {
  express = require("express")();
  express.get("/:id?/:size?", function(req, res) {
    return reply(req, res);
  });
  express.enable("trust proxy", true);
  express.listen(80, function() {
    return console.log("[INFO] Listening...");
  });
} catch (error) {
  err = error;
  exports.reply = function(req, res) {
    return reply(req, res);
  };
  console.log("[WARN] Express is not loaded, using serverless implementation...");
}

request = require("request-promise-cache");

// Fetch the user profile from a UUID or username.

// @param {string} id - UUID or username.
// @returns {promise<object>} - User profile as JSON.
profile = function(id) {
  return request({
    uri: `https://api.ashcon.app/minecraft/user/${id}`,
    json: true,
    transform2xxOnly: true,
    cacheTTL: 300
  });
};

// Fetch and download binary data as a buffer.

// @param {string} url - URL of the binary file to fetch.
// @returns {promise<buffer>} - Binary file as a buffer.
binary = function(url) {
  return request({
    uri: url,
    encoding: null,
    transform2xxOnly: true,
    cacheTTL: 300
  // BUG: Cached requests do not return Buffer, but an object containing it
  }).then(function(buf) {
    if (Buffer.isBuffer(buf)) {
      return buf;
    } else {
      return Buffer.from(buf.data);
    }
  });
};
